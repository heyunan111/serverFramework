<p>这是一个基于协程的轻量级线程库的代码实现。该类的构造函数通过传入一个函数指针来创建一个协程对象，同时也可以指定协程的栈大小和是否使用调用者
的栈。在构造函数中，还为协程对象分配了一个栈，使用getcontext函数获取上下文对象的副本，通过 ` makecontext ` 函数将上下文与协程的入口函数绑定。析
构函数则是用于回收协程的资源，同时也会断言当前协程对象的状态。reset函数用于重置协程的函数指针，并将协程状态设置为INIT。swap_in和swap_out
函数用于协程之间的切换，通过swapcontext函数实现，而yield函数用于将当前协程切换至就绪状态，并让出CPU资源。总体来说，该代码实现了基本的协程
功能，并提供了一些辅助函数来方便协程的调度和管理。<p>

> ### Fiber::Fiber(std::function void() cb, size_t stacksize, bool use_caller)

<p>构造函数。构造函数接受三个参数：一个无返回值的函数指针cb，一个栈大小stacksize，和一个bool类型的参数use_caller。其中，cb表示协程需要
执行的函数，stacksize表示协程的栈大小，use_caller表示是否使用调用者的上下文。在构造函数中，首先给协程分配了栈空间，然后获取了上下文对象的
副本，并将其关联到协程上下文中。接着，根据use_caller参数的值来选择是调用主协程函数还是调用调用者协程函数。最后，输出调试信息，并将协程数量
加1。</p>

> ### Fiber::~Fiber()

<p>析构函数，用于销毁一个协程对象。首先，将协程计数器减1。然后，如果协程栈存在，确保协程状态为 INIT、TERM 或 EXCEPT，然后释放协程栈；否则
，确保协程状态为 EXEC，并且当前协程为待销毁协程，然后将当前协程对象指针设为 nullptr。最后，输出一条调试信息，表示协程对象已经被销毁。</p>

> ### swap_in()

<p>这是一个协程类的方法，它用于将当前协程切换到执行状态。具体来说，它会将当前协程的状态设置为"EXEC"，然后使用swapcontext函数将当前协程的
上下文切换到目标协程的上下文中。在切换之前，它还将当前协程设置为"this"，以便在需要时可以通过GetThis()函数获取当前协程的指针。如果切换上下
文失败，它会打印错误信息并抛出一个运行时异常。</p>

> ### Fiber::swap_out()
<p>这个 swap_out() 函数用于将当前的协程切出（即切换到主协程），保存当前协程的上下文并恢复主协程的上下文。它使用了 swapcontext() 函数来完成协程之间的切换。首先，它获取主协程的上下文，并使用 swapcontext() 函数将当前协程的上下文保存到栈中。然后，它将当前协程设置为主协程，并使用 swapcontext() 函数将主协程的上下文恢复到 CPU 寄存器中，以便继续执行主协程的代码。这个函数的作用是将 CPU 的控制权从当前协程转移到主协程，以便其他协程可以获得执行的机会。</p>

> ### Fiber::YieldToReady()

<p>这是一个协程库中的函数，用于将当前协程切出执行状态，并切换到可执行状态的下一个协程。函数首先获取当前协程，将其状态设置为可执行状态（READY），然后调用 swap_out() 函数，将当前协程切出执行状态，将控制权交还给调度器，由调度器选择下一个可执行状态的协程并切换到其上下文，从而实现协程之间的切换。<p>

> ### Fiber::MainFunc()
<p>这是一个静态成员函数，用作协程的执行函数。它通过GetThis获取当前正在执行的协程，然后执行该协程的回调函数m_cb，并将协程状态设置为TERM，表示该协程已完成执行。如果执行回调函数期间抛出了异常，则将协程状态设置为EXCEPT，并记录异常信息和当前的回溯信息。最后，通过swap_out函数切换到主协程。 在回调函数执行完成之后，将协程的m_cb成员设置为nullptr，以避免回调函数被多次执行。最后，通过reset函数释放cur智能指针所占有的内存，同时通过swap_out函数切换到主协程。</p>

> ### Fiber::CallerMainFunc()
<p>CallerMainFunc是协程调用方使用的入口函数。在这个函数中，协程会执行传入的回调函数 m_cb，并在回调函数执行完毕后进行状态转移。如果回调函数执行过程中发生异常，协程状态将转移为 EXCEPT，否则将转移为 TERM。最后，协程将通过 back() 方法返回到协程调度器，切换到协程调用方的上下文中。</p>
