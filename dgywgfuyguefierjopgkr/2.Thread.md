全部封装自pthread，因为在Linux平台下，C++11的多线程库通常使用POSIX线程库（pthread）实现，所以封装C++11线程库还不如直接封装pthread

---

### 信号量

信号量本质上是一个变量，用于跟踪可用资源的数量。当线程想要访问资源时，它必须先获取信号量。如果信号量值大于零，则线程将减小信号量值并继续访问资源。如果信号量值为零，则线程会阻塞，直到另一个线程通过增加信号量值释放资源。
Pthreads 提供两种类型的信号量：二进制信号量和计数信号量。

二进制信号量：二进制信号量的值只能为 0 或 1。当一个线程获取二进制信号量时，如果其值为 1，则将其减为 0 并继续执行。如果其值为
0，则线程将阻塞，直到有另一个线程将其值增加为 1。
二进制信号量通常用于保护单个资源，例如一个文件或一块共享内存。在这种情况下，只有一个线程可以访问资源，而其他线程必须等待该线程释放它。

计数信号量：计数信号量的值可以是任何非负整数。当一个线程获取计数信号量时，如果其值大于 0，则将其减小并继续执行。如果其值为
0，则线程将阻塞，直到有另一个线程将其值增加为大于 0 的值。
计数信号量通常用于管理资源池，例如线程池或连接池。在这种情况下，多个线程可以同时访问资源，但是资源的数量是有限的，因此必须使用信号量来同步线程之间的访问。

boost:noncopyable:实现非常简单，通过显示删除(或者设为private)拷贝构造和赋值运算符重载，达到禁止拷贝的目的

使用计数信号量封装Semaphore类，同时继承boost:noncopyable防止拷贝。内部是对pthread semaphore的简单封装。

---

### 互斥量

**_互斥量封装了普通互斥量mutex_**

互斥量：是一种用于线程同步的基本同步工具，用于保护共享数据结构的一致性。它是一种信号量，只有两种状态，被占用和未被占用，它可以控制对共享资源的独占访问，保证同一时间只有一个线程可以访问共享资源，从而避免竞态条件的发生。

互斥量有两个基本操作：加锁和解锁。当一个线程需要访问共享资源时，它需要获取互斥量的锁，如果锁已经被其他线程占用，那么该线程就会进入阻塞状态，直到锁被释放。在访问共享资源的过程中，其他线程无法获取该互斥量的锁，也无法访问共享资源，只能等待当前线程释放锁后才能再次尝试获取锁。

互斥量有两种类型：递归互斥量和非递归互斥量。递归互斥量允许同一线程多次加锁，但是要保证解锁的次数与加锁的次数相等，否则会出现死锁的情况。非递归互斥量不允许同一线程多次加锁，如果一个线程已经持有了该互斥量的锁，那么再次尝试加锁会导致阻塞。

**_封装中使用了非递归互斥量而非递归互斥量，因为递归互斥量存在以下问题：_**  
1.死锁：虽然递归互斥量允许同一线程多次获得锁，但是如果不注意使用的话，也可能出现死锁的情况。例如，如果线程A已经持有锁，然后它再次尝试获得锁，但是在等待锁的过程中被另一个线程B抢占了CPU，那么B可能永远无法获得锁，导致死锁。

2.性能问题：递归互斥量比普通的互斥量更复杂，因此使用递归互斥量的代码通常比使用普通互斥量的代码运行更慢。在一些对性能要求比较高的场合，使用递归互斥量可能会成为瓶颈。

3.设计问题：递归互斥量的存在可能意味着程序的设计不够合理。通常情况下，应该尽量避免出现一个线程多次获取同一把锁的情况，这可能是因为程序设计上的缺陷。如果程序中频繁使用递归互斥量，那么可能需要重新设计程序的结构。

递归互斥量的使用场景：  
1.递归函数中需要对共享资源进行保护。

2.多个函数中需要对同一个共享资源进行保护，而这些函数又可能被同一个线程多次调用。

3.某个线程需要获取一个锁，然后在锁的保护下进行多个操作，包括调用其他函数等。


---

### 锁

封装了 **_(局部读锁，局部写锁)->读写锁，自旋锁，原子锁，协程锁_**  
全部使用`RAII(资源获取即初始化(Resource Acquisition is Initialization))`技术

**_读写锁：_**  
读写锁是一种多线程并发控制机制，它允许多个线程同时读共享资源，但只允许一个线程写共享资源。

读写锁有两种模式：读模式和写模式。在读模式下，多个线程可以同时获取读锁并访问共享资源，而在写模式下，只有一个线程可以获取写锁并访问共享资源，其他线程必须等待。

读写锁的使用场景通常是在读多写少的情况下，使用读写锁可以提高并发性能。读写锁可以降低锁的竞争，从而提高了多线程读取共享资源的效率。但是，如果读写锁的使用频率很高，而且读线程和写线程的数量差不多，那么读写锁的性能可能会劣于互斥锁，因为读写锁的开销比互斥锁大。

**_自旋锁：_**  
自旋锁是一种用于同步的锁，它使用忙等待的方式来避免线程的上下文切换带来的开销。在自旋锁被占用的情况下，请求锁的线程会一直循环忙等待直到锁被释放。相对于互斥锁等传统的锁，自旋锁适用于在锁的占用时间短且线程数较少的情况下。

**_原子锁(非RAII)：_**  
这是一个使用C++11中的atomic头文件实现的原子锁。它被定义为一个类，并使用了boost库中的noncopyable类避免了拷贝和赋值。CASLock支持ScopedLockImpl和局部锁（Lock），这意味着它可以像其他锁一样通过局部锁在一定的代码块中上锁和解锁。这个锁在上锁时使用while循环来不断地测试原子状态，并等待其变为false。在解锁时，它简单地将原子状态设置为false。原子锁是一种非常轻量级的锁，适用于对临界区访问时间非常短的情况。

**_协程锁：_**  
协程锁的实现主要是通过一个计数器和一个等待队列来实现的。协程在请求锁时，如果当前的计数器大于
0，则减小计数器并返回；否则将当前协程加入等待队列并暂停协程。在释放锁时，如果等待队列中有协程，则取出队首协程并恢复它的执行。

---

### 线程

封装了pthread线程的类，包含了线程ID，线程结构，线程执行函数，线程名称和信号量等成员变量。提供了join方法等待线程执行完成，GetThis方法获取当前线程的智能指针，GetName和SetName方法获取和设置线程名称。其中run方法是线程的执行函数。   
`run():`
该函数作为线程的入口函数，在新创建的线程中运行。函数中先将当前线程的Thread对象指针和名称保存到线程局部存储中，然后获取线程ID，并将线程名字设置为该线程名字的前15个字符。接着，用std::
function保存需要在线程中执行的函数，并释放线程的信号量以通知调用者线程已经准备好。最后调用保存的函数并返回。

线程（Thread）是指程序执行流的最小单元，是 CPU
调度和分派的基本单位。一个进程可以有多个线程，这些线程可以并发执行，彼此之间共享进程资源，比如内存、文件句柄等。线程之间的通信和同步需要借助于特定的机制，比如锁、条件变量等。

在多线程编程中，开发者可以通过创建线程来实现并发执行，从而提高程序的运行效率和响应速度。

超线程技术，也称为“超线程技术”或“逻辑核心技术”，是一种利用CPU硬件实现并行计算的技术。它是Intel Hyper-Threading技术的商标名称，也是AMD
Simultaneous Multi-Threading技术的一种实现方式。

超线程技术通过将一个CPU核心模拟成多个逻辑处理单元（线程），实现了在同一时刻执行多个线程的能力。这种技术可以使CPU在单个周期内完成更多的工作量，从而提高计算性能和效率。超线程技术可以在一些特定的应用场景中获得显著的性能提升，例如多任务操作系统、多线程应用程序等。

超线程技术的实现需要硬件支持，包括特殊的处理器芯片设计和处理器内部的超线程逻辑电路。通过超线程技术，处理器能够在同一时间处理更多的任务，从而提高了系统的吞吐量。但超线程技术并不是所有应用场景都能够发挥作用，例如密集型计算任务可能无法从中获益，因为它们需要所有的CPU资源来完成单个任务。