### 协程

协程是一种用户级别的轻量级线程，也被称为“协作式多任务处理”（cooperative
multitasking）。协程的实现并不像线程那样需要在内核中创建和销毁线程上下文，从而减少了线程切换的开销。相反，协程只需要在用户空间中保存一些状态，比如栈、指令指针等，当一个协程切换到另一个协程时，只需保存当前协程的状态，然后恢复另一个协程的状态即可。

有栈协程和无栈协程：   
有栈协程：每个协程都有一个固定大小的栈，它在创建协程时被分配，然后在线程的堆栈上保存。在执行协程时，协程从自己的栈上获取空间来保存局部变量和函数调用的上下文。当协程不再需要时，它的栈空间将被释放。

无栈协程：相比之下，无栈协程不维护自己的栈，它们共享线程的栈。当协程切换时，它们将使用一个固定大小的上下文结构体来保存它们的状态，而不是保存在栈上。由于不需要在堆上分配和释放栈空间，因此无栈协程的内存管理开销更小。

因此，无栈协程在创建和销毁时的性能更高，并且对内存的使用更加高效，但它们不能直接访问线程的栈，而需要通过上下文切换来共享状态。相比之下，有栈协程可以访问自己的栈，但需要更多的内存管理开销。

`ucontext.h`是一个用于实现协程、线程和信号处理等功能的上下文切换工具。它包含了程序的堆栈、程序计数器和一些寄存器等状态信息，可以在不同的上下文之间进行快速切换。

**_本项目中使用有栈协程_**

状态管理：协程有多个状态，如初始化状态`INIT`、暂停状态`HOLD`、执行状态 `EXEC`、结束状态 `TERM`、可执行状态 `READY`
、异常状态 `EXCEPT`。协程的状态管理是通过枚举类型 State 和类成员变量 m_state 实现的。

协程上下文管理：协程的上下文保存和切换是通过操作系统提供的 ucontext_t 结构体实现的。在 Fiber 类中，定义了成员变量 `m_ctx`
来保存协程的上下文。

协程栈管理：协程需要有自己的运行栈。在 Fiber 类中，定义了成员变量 m_stack 来保存协程的运行栈，并通过 get_stack_size()
函数获取运行栈的大小。

协程创建和销毁：协程的创建和销毁是通过 Fiber 类的构造函数和析构函数实现的。在构造函数中，通过 makecontext()
函数创建协程的上下文和运行栈，并指定协程的入口函数。在析构函数中，通过 swapcontext() 函数将协程的上下文和运行栈释放掉。

协程调度和切换：协程的调度和切换是通过操作系统提供的 swapcontext() 函数实现的。在 Fiber 类中，定义了成员函数 swap_in() 和
swap_out() 来实现协程的切换。

协程异常处理：协程可能出现异常，需要进行相应的处理。在 Fiber 类中，定义了成员变量 m_except 和 m_error 来保存协程的异常信息，并提供了相应的函数
set_exception() 和 get_exception() 来设置和获取协程的异常信息。

协程状态切换：协程的状态切换是通过 set_state() 函数实现的。在 Fiber 类中，定义了成员变量 m_state 来保存协程的状态，并提供了相应的函数
get_state() 和 set_state() 来获取和设置协程的状态。
